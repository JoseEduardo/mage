(import
  '(java.util Calendar GregorianCalendar)
  '(javax.swing JFrame JLabel))
(import '(mage.game Game))
(Game.)
(Game. 1)
(import '(mage.cards.n N1Starfighter))
(import '(mage.game GameImpl))
(GameImpl. 1)
(GameImpl. )
(GameImpl.)
(new GameImpl)
(GameImpl)
GameImpl
mage.constants.RangeOfInfluence$ALL
mage.constants.RangeOfInfluence/ALL
(GameImpl. mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL 1 2)
(GameImpl. mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL)
exit
(mage.game.GameImpl. mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL 1 2)
(mage.game.GameImpl. mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL "1" "2")
(mage.cards.Sets/generateRandomCardPool 1)
(mage.cards.Sets/generateRandomCardPool 1 [])
(mage.cards.Sets/generateRandomCardPool 1 [mage.constants.ColoredManaSymbol/R])
(mage.cards.Sets/generateRandomCardPool 10 [mage.constants.ColoredManaSymbol/R])
java.util.concurrent.ThreadLocalRandom.nextInt
(mage.cards.a.AdventOfTheWurm (mage.cards.CardSetInfo. "Foo" "FOO" mage.constants.Rarity/RARE))
(mage.cards.a.AdventOfTheWurm (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE))
(mage.cards.a.AdventOfTheWurm. (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE))
(mage.cards.a.AdventOfTheWurm. java.util.UUID/randomUUID (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE))
(mage.cards.a.AdventOfTheWurm. (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE))
(bean (mage.cards.a.AdventOfTheWurm. (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE)))
(clojure.pprint/pp (bean (mage.cards.a.AdventOfTheWurm. (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE)))
)
(clojure.pprint/pprint (bean (mage.cards.a.AdventOfTheWurm. (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE))))
(def c (clojure.pprint/pprint (bean (mage.cards.a.AdventOfTheWurm. (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE)))))
(def c (mage.cards.a.AdventOfTheWurm. (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE))
)
(javadoc c)
c
(.abilities c)
(.getAbilities c)
(def c (mage.cards.o.OdricLunarchMarshal (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE))
)
(def c (mage.cards.o.OdricLunarchMarshal. (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE))
)
c
(.getAbilities c)
(.getEffects c)
(.getAbilities c)
(map #(.getSubAbilities %) (.getAbilities c)
)
(flatten (map #(.getSubAbilities %) (.getAbilities c)))
(flatten (map #(.getManaCosts %) (.getAbilities c)))
(def c (mage.cards.s.Sunbond (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE)))
(def c (mage.cards.s.Sunbond. (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE)))
(flatten (map #(.getManaCosts %) (.getAbilities c)))
(flatten (map #(.getEffects %) (.getAbilities c)))
(flatten (map #(.getEffects %) (.isUsesStack c)))
(flatten (map #(.getEffects %) (.getRule c)))
(def c (mage.cards.s.Sunbond. (java.util.UUID/randomUUID) (mage.cards.CardSetInfo. "Foo" "FOO" "1" mage.constants.Rarity/RARE)))
(flatten (map #(.getEffects %) (.getAbilities c)))
(flatten (map #(.getRules %) (.getAbilities c)))
(flatten (map #(.getRule %) (.getAbilities c)))
(flatten (map #(.getRule % true) (.getAbilities c)))
(flatten (map #(.getAllEffects %) (.getAbilities c)))
(flatten (map #((.getAllEffects %)) (.getAbilities c)))
(flatten (map #(.getAllEffects %) (.getAbilities c)))
(map (.getValue %) (flatten (map #(.getAllEffects %) (.getAbilities c)))
)
(map #(.getValue %) (flatten (map #(.getAllEffects %) (.getAbilities c))))
(map (fn (ability) (map (fn (effect) (.getValue effect)) (flatten (map #(.getAllEffects %) (.getAbilities c))))
)
(map (fn [ability] (map (fn [effect] (.getValue effect)) (flatten (map #(.getAllEffects %) (.getAbilities c))))))
(map (fn [ability] (map (fn [effect] (.toString (.getValue effect))) (flatten (map #(.getAllEffects %) (.getAbilities c))))))
(map (fn [ability] (map (fn [effect] (.toString (.getValue effect)))) (flatten (map #(.getAllEffects %) (.getAbilities c))))))
(map (fn [ability] (map (fn [effect] (.toString (.getValue effect)))) (flatten (map #(.getAllEffects %) (.getAbilities c)))))
(map (fn [ability] (map (fn [effect] (.toString (.getValue effect))))) (flatten (map #(.getAllEffects %) (.getAbilities c)))))
(map (fn [ability] (map (fn [effect] (.toString (.getValue effect))))) (flatten (map #(.getAllEffects %) (.getAbilities c))))
(flatten (map #(.getEffects %) (.getAbilities c)))
(flatten (map #(bean (.getEffects %)) (.getAbilities c)))
(flatten (map #(bean (.getSubAbilities %)) (.getAbilities c)))
(flatten (map #({:a bean (.getEffects %)}) (.getAbilities c)))
(flatten (map #( { :a  (.getEffects %)}) (.getAbilities c)))
(flatten (map #(bean (.getEffects %)) (.getAbilities c)))
(flatten (map #(into [] (.getRule true) (.getEffects %)) (.getAbilities c)))
(flatten (map #(into [] (.getRule % true) (.getEffects %)) (.getAbilities c)))
(flatten (map #(.getRule % true)) (.getAbilities c)))
(flatten (map #(.getRule % true) (.getAbilities c)))
(flatten (map #(.getTargets % true) (.getAbilities c)))
(flatten (map #(.getTargets %) (.getAbilities c)))
(map bean (flatten (map #(.getTargets %) (.getAbilities c))))
(map bean (flatten (map #(.getManaCostsToPay %) (.getAbilities c))))
(map clojure.pprint/pprint (flatten (map #(.getManaCostsToPay %) (.getAbilities c))))
q
(map .toString (flatten (map #(.getManaCostsToPay %) (.getAbilities c))))
(flatten (map #(.getManaCostsToPay %) (.getAbilities c)))
c
(flatten (map #(.toArray (.getManaCostsToPay %)) (.getAbilities c)))
(flatten (map #(map bean (.toArray (.getManaCostsToPay %))) (.getAbilities c)))
(flatten (map #(map (fn [cost] (.getText cost) (.toArray (.getManaCostsToPay %))) (.getAbilities c)))
)
(flatten (map #(map (fn [cost] (.getText cost) (.toArray (.getManaCostsToPay %)))) (.getAbilities c))))
(flatten (map #(map (fn [cost] (.getText cost) (.toArray (.getManaCostsToPay %)))) (.getAbilities c)))
(flatten (map #(map (fn [cost] (.getText cost)) (.toArray (.getManaCostsToPay %)))) (.getAbilities c)))
(flatten (map #(map (fn [cost] (.getText cost)) (.toArray (.getManaCostsToPay %)))) (.getAbilities c))))
(flatten (map #(map (fn [cost] (.getText cost)) (.toArray (.getManaCostsToPay %)))) (.getAbilities c)
)
(map #(map (fn [cost] (.getText cost)) (.toArray (.getManaCostsToPay %)))) (.getAbilities c)
(flatten (map #(map (fn [cost] (.getText cost)) (.toArray (.getManaCostsToPay %)))) (.getAbilities c))
(map #(map (fn [cost] (.getText cost)) (.toArray (.getManaCostsToPay %)))) (.getAbilities c)
(map #(map (fn [cost] (.getActionText cost)) (.toArray (.getManaCostsToPay %)))) (.getAbilities c)
(clojure.lang.Reflector/invokeConstructor mage.game.GameImpl (to-array [mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL]))
(clojure.lang.Reflector/invokeConstructor mage.game.GameImpl (to-array [mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL 20 1]))
(clojure.lang.Reflector/invokeConstructor mage.game.Game (to-array [mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL 20 1]))
(clojure.lang.Reflector/invokeConstructor mage.game.Game (to-array []))
(clojure.lang.Reflector/invokeConstructor mage.game.GameI (to-array []))
(clojure.lang.Reflector/invokeConstructor mage.game.GameImpl (to-array []))
(set! *warn-on-reflection* true)
(clojure.lang.Reflector/invokeConstructor mage.game.GameImpl (to-array []))
(mage.game.GameImpl.)
(mage.game.Game. mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL 20 1)
(mage.game.GameImpl. mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL 20 1)
(.newInstance mage.game.GameImpl mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL 20 1)
(new mage.game.GameImpl mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL 20 1)
(new mage.game.GameImpl mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL (new Integer 1) (new Integer 2))
(new mage.game.Game mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL (new Integer 1) (new Integer 2))
(mage.game.Game. mage.constants.MultiplayerAttackOption/RIGHT mage.constants.RangeOfInfluence/ALL (new Integer 1) (new Integer 2))
(defmacro sub-person [& args] 
   `(proxy [Person] [~@args] 
(proxy [mage.game.Game] )
(proxy [mage.game.Game] (toString))
(proxy [mage.game.Game] (toString []))
(proxy [mage.game.Game] [] (toString []))
(new (proxy [mage.game.Game] [] (toString [])))
(bean (proxy [mage.game.Game] [] (toString [])))
